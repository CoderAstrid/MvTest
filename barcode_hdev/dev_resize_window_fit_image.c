/*****************************************************************************
 * File generated by HDevelop for HALCON/C Version 19.05.0.0
 * Non-ASCII strings in this file are encoded in UTF-8.
 * 
 * Please note that non-ASCII characters in string constants are exported
 * as octal codes in order to guarantee that the strings are correctly
 * created on all systems, independent on any compiler settings.
 * 
 * Source files with different encoding should not be mixed in one project.
 *****************************************************************************/




#ifndef __APPLE__
#  include "HalconC.h"
#  include "halconc/Hdevthread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONC/HalconC.h>
#    include <HALCONC/Hdevthread.h>
#  else
#    include <HALCONCxl/HalconC.h>
#    include <HALCONCxl/Hdevthread.h>
#  endif
#endif



/* Chapter: Develop*/
/* Short Description: Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image */
void dev_resize_window_fit_image (Hobject ho_Image, Htuple hv_Row, Htuple hv_Column, 
    Htuple hv_WidthLimit, Htuple hv_HeightLimit)
{


  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */

  /* Local control variables */
  Htuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  Htuple  hv_MaxHeight, hv_ResizeFactor, hv_Pointer, hv_Type;
  Htuple  hv_ImageWidth, hv_ImageHeight, hv_TempWidth, hv_TempHeight;
  Htuple  hv_WindowWidth, hv_WindowHeight;

  /* Initialize control variables */
  create_tuple(&hv_MinWidth,0);
  create_tuple(&hv_MaxWidth,0);
  create_tuple(&hv_MinHeight,0);
  create_tuple(&hv_MaxHeight,0);
  create_tuple(&hv_ResizeFactor,0);
  create_tuple(&hv_Pointer,0);
  create_tuple(&hv_Type,0);
  create_tuple(&hv_ImageWidth,0);
  create_tuple(&hv_ImageHeight,0);
  create_tuple(&hv_TempWidth,0);
  create_tuple(&hv_TempHeight,0);
  create_tuple(&hv_WindowWidth,0);
  create_tuple(&hv_WindowHeight,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*This procedure adjusts the size of the current window*/
  /*such that it fits into the limits specified by WidthLimit*/
  /*and HeightLimit, but also maintains the correct image aspect ratio.*/
  /**/
  /*If it is impossible to match the minimum and maximum extent requirements*/
  /*at the same time (f.e. if the image is very long but narrow),*/
  /*the maximum value gets a higher priority,*/
  /**/
  /*Parse input tuple WidthLimit*/
  /*========== if (|WidthLimit| == 0 or WidthLimit < 0) ==========*/
  T_tuple_length(hv_WidthLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(hv_WidthLimit,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinWidth := 500*/
    reuse_tuple_i(&hv_MinWidth,500);

    /*MaxWidth := 800*/
    reuse_tuple_i(&hv_MaxWidth,800);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (|WidthLimit| == 1) ==========*/

  T_tuple_length(hv_WidthLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinWidth := 0*/
    reuse_tuple_i(&hv_MinWidth,0);

    /*MaxWidth := WidthLimit*/
    destroy_tuple(hv_MaxWidth);
    copy_tuple(hv_WidthLimit,&hv_MaxWidth);

  }
  else
  {
    /*MinWidth := WidthLimit[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_WidthLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MinWidth);
    hv_MinWidth=TTemp[--SP];

    /*MaxWidth := WidthLimit[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_WidthLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MaxWidth);
    hv_MaxWidth=TTemp[--SP];

  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*Parse input tuple HeightLimit*/
  /*========== if (|HeightLimit| == 0 or HeightLimit < 0) ==========*/
  T_tuple_length(hv_HeightLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  create_tuple_i(&TTemp[SP++],0);
  T_tuple_less(hv_HeightLimit,TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-1]=TTemp[SP];
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinHeight := 400*/
    reuse_tuple_i(&hv_MinHeight,400);

    /*MaxHeight := 600*/
    reuse_tuple_i(&hv_MaxHeight,600);

  }
  else
  {
  destroy_tuple(TTemp[--SP]);
  /*========== elseif (|HeightLimit| == 1) ==========*/

  T_tuple_length(hv_HeightLimit,&TTemp[SP++]);
  create_tuple_i(&TTemp[SP++],1);
  T_tuple_equal(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*MinHeight := 0*/
    reuse_tuple_i(&hv_MinHeight,0);

    /*MaxHeight := HeightLimit*/
    destroy_tuple(hv_MaxHeight);
    copy_tuple(hv_HeightLimit,&hv_MaxHeight);

  }
  else
  {
    /*MinHeight := HeightLimit[0]*/
    create_tuple_i(&TTemp[SP++],0);
    T_tuple_select(hv_HeightLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MinHeight);
    hv_MinHeight=TTemp[--SP];

    /*MaxHeight := HeightLimit[1]*/
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_select(hv_HeightLimit,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_MaxHeight);
    hv_MaxHeight=TTemp[--SP];

  }
  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /**/
  /*Test, if window size has to be changed.*/
  /*ResizeFactor := 1*/
  reuse_tuple_i(&hv_ResizeFactor,1);

  /*get_image_pointer1 (Image, Pointer, Type, ImageWidth, ImageHeight)*/
  destroy_tuple(hv_Pointer);
  destroy_tuple(hv_Type);
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  /***/T_get_image_pointer1(ho_Image, &hv_Pointer, &hv_Type, &hv_ImageWidth, &hv_ImageHeight);

  /*First, expand window to the minimum extents (if necessary).*/
  /*========== if (MinWidth > ImageWidth or MinHeight > ImageHeight) ==========*/
  T_tuple_greater(hv_MinWidth,hv_ImageWidth,&TTemp[SP++]);
  T_tuple_greater(hv_MinHeight,hv_ImageHeight,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*ResizeFactor := max([real(MinWidth) / ImageWidth,real(MinHeight) / ImageHeight])*/
    T_tuple_real(hv_MinWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_ImageWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_real(hv_MinHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_ImageHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP=SP-1;
    T_tuple_max(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    destroy_tuple(hv_ResizeFactor);
    hv_ResizeFactor=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*TempWidth := ImageWidth * ResizeFactor*/
  T_tuple_mult(hv_ImageWidth,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_TempWidth);
  hv_TempWidth=TTemp[--SP];

  /*TempHeight := ImageHeight * ResizeFactor*/
  T_tuple_mult(hv_ImageHeight,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_TempHeight);
  hv_TempHeight=TTemp[--SP];

  /*Then, shrink window to maximum extents (if necessary).*/
  /*========== if (MaxWidth < TempWidth or MaxHeight < TempHeight) ==========*/
  T_tuple_less(hv_MaxWidth,hv_TempWidth,&TTemp[SP++]);
  T_tuple_less(hv_MaxHeight,hv_TempHeight,&TTemp[SP++]);
  T_tuple_or(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
  destroy_tuple(TTemp[SP-2]);
  destroy_tuple(TTemp[SP-1]);
  TTemp[SP-2]=TTemp[SP];
  SP=SP-1;
  if(get_i(TTemp[SP-1],0))
  {
    /*ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])*/
    copy_tuple(hv_ResizeFactor,&TTemp[SP++]);
    T_tuple_real(hv_MaxWidth,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_TempWidth,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_real(hv_MaxHeight,&TTemp[SP++]);
    T_tuple_div(TTemp[SP-1],hv_TempHeight,&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_concat(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP=SP-1;
    T_tuple_min(TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    T_tuple_mult(TTemp[SP-2],TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-2]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-2]=TTemp[SP];
    SP=SP-1;
    destroy_tuple(hv_ResizeFactor);
    hv_ResizeFactor=TTemp[--SP];

  }
  destroy_tuple(TTemp[--SP]);
  /*========== end if ==========*/
  /*WindowWidth := ImageWidth * ResizeFactor*/
  T_tuple_mult(hv_ImageWidth,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_WindowWidth);
  hv_WindowWidth=TTemp[--SP];

  /*WindowHeight := ImageHeight * ResizeFactor*/
  T_tuple_mult(hv_ImageHeight,hv_ResizeFactor,&TTemp[SP++]);
  destroy_tuple(hv_WindowHeight);
  hv_WindowHeight=TTemp[--SP];

  /*Resize window*/
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_window_extents (Row, Column, WindowWidth, WindowHeight)*/
    /***/T_set_window_extents(active_win,hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight);
    destroy_tuple(active_win);
  }
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)*/
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],0);
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_ImageHeight,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],1);
    T_tuple_sub(hv_ImageWidth,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    /***/T_set_part(active_win,TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  /*========== return ==========*/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local control variables */
  destroy_tuple(hv_MinWidth);
  destroy_tuple(hv_MaxWidth);
  destroy_tuple(hv_MinHeight);
  destroy_tuple(hv_MaxHeight);
  destroy_tuple(hv_ResizeFactor);
  destroy_tuple(hv_Pointer);
  destroy_tuple(hv_Type);
  destroy_tuple(hv_ImageWidth);
  destroy_tuple(hv_ImageHeight);
  destroy_tuple(hv_TempWidth);
  destroy_tuple(hv_TempHeight);
  destroy_tuple(hv_WindowWidth);
  destroy_tuple(hv_WindowHeight);

  return;

  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

}
