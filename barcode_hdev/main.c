/*****************************************************************************
 * File generated by HDevelop for HALCON/C Version 19.05.0.0
 * Non-ASCII strings in this file are encoded in UTF-8.
 * 
 * Please note that non-ASCII characters in string constants are exported
 * as octal codes in order to guarantee that the strings are correctly
 * created on all systems, independent on any compiler settings.
 * 
 * Source files with different encoding should not be mixed in one project.
 *****************************************************************************/



#ifndef __APPLE__
#  include "HalconC.h"
#  include "halconc/Hdevthread.h"
#  if defined(__linux__) && (defined(__i386__) || defined(__x86_64__)) \
                         && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONC/HalconC.h>
#    include <HALCONC/Hdevthread.h>
#  else
#    include <HALCONCxl/HalconC.h>
#    include <HALCONCxl/Hdevthread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif


/* Procedure declarations */
/* External procedures */
/* Chapter: Develop*/
/* Short Description: Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image */
extern void dev_resize_window_fit_image (Hobject ho_Image, Htuple hv_Row, Htuple hv_Column, 
    Htuple hv_WidthLimit, Htuple hv_HeightLimit);
/* Chapter: Graphics / Text*/
/* Short Description: Set font independent of OS */
extern void set_display_font (Htuple hv_WindowHandle, Htuple hv_Size, Htuple hv_Font, 
    Htuple hv_Bold, Htuple hv_Slant);

/* Procedures */
#ifndef NO_EXPORT_MAIN
/* Main procedure */
void action()
{
  /* Stack for temporary tuples */
  Htuple   TTemp[100];
  int      SP=0;
  /* Stack for temporary tuple vectors */
  Hvector  TVTemp[100] = {0};
  int      SPTV=0;

  /* Local iconic variables */
  Hobject  ho_Image, ho_SymbolRegions;

  /* Local control variables */
  Htuple  hv_BarCodeHandle, hv_WindowHandle, hv_DecodedDataStrings;
  Htuple  hv_res, hv_Area, hv_Row, hv_Column;

  /* Initialize iconic variables */
  gen_empty_obj(&ho_Image);
  gen_empty_obj(&ho_SymbolRegions);

  /* Initialize control variables */
  create_tuple(&hv_BarCodeHandle,0);
  create_tuple(&hv_WindowHandle,0);
  create_tuple(&hv_DecodedDataStrings,0);
  create_tuple(&hv_res,0);
  create_tuple(&hv_Area,0);
  create_tuple(&hv_Row,0);
  create_tuple(&hv_Column,0);

  /****************************************************/
  /******************   Begin procedure   *************/
  /****************************************************/

  /*Read bar codes of type Code 128*/
  /**/
  /*create_bar_code_model ([], [], BarCodeHandle)*/
  create_tuple(&TTemp[SP++],0);
  create_tuple(&TTemp[SP++],0);
  destroy_tuple(hv_BarCodeHandle);
  /***/T_create_bar_code_model(TTemp[SP-2], TTemp[SP-1], &hv_BarCodeHandle);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_pop(&active_win);
    T_close_window(active_win);
    destroy_tuple(active_win);
  }
  /*dev_open_window (0, 0, 600, 600, 'black', WindowHandle)*/
  create_tuple_s(&TTemp[SP++],"black");
  create_tuple_s(&TTemp[SP++],"background_color");
  T_set_window_attr(TTemp[SP-1],TTemp[SP-2]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],600);
  create_tuple_i(&TTemp[SP++],600);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"visible");
  create_tuple_s(&TTemp[SP++],"");
  destroy_tuple(hv_WindowHandle);
  /***/T_open_window(TTemp[SP-7],TTemp[SP-6],TTemp[SP-5],TTemp[SP-4],TTemp[SP-3],TTemp[SP-2],TTemp[SP-1],&hv_WindowHandle);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  hdev_window_stack_push(hv_WindowHandle);

  /*set_display_font (WindowHandle, 16, 'mono', 'true', 'false')*/
  create_tuple_i(&TTemp[SP++],16);
  create_tuple_s(&TTemp[SP++],"mono");
  create_tuple_s(&TTemp[SP++],"true");
  create_tuple_s(&TTemp[SP++],"false");
  /***/set_display_font(hv_WindowHandle, TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_draw ('margin')*/
    create_tuple_s(&TTemp[SP++],"margin");
    /***/T_set_draw(active_win,TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_color ('green')*/
    create_tuple_s(&TTemp[SP++],"green");
    /***/T_set_color(active_win,TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_set_line_width (3)*/
    create_tuple_i(&TTemp[SP++],3);
    /***/T_set_line_width(active_win,TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }
  /*read_image (Image, 'F:/Data/Barcode/test_error/20210817062009009.jpg')*/
  clear_obj(ho_Image);
  /***/read_image(&ho_Image, "F:/Data/Barcode/test_error/20210817062009009.jpg");

  /*dev_resize_window_fit_image (Image, 0, 0, -1, -1)*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_i(&TTemp[SP++],-1);
  create_tuple_i(&TTemp[SP++],-1);
  /***/dev_resize_window_fit_image(ho_Image, TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], 
      TTemp[SP-1]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*find_bar_code (Image, SymbolRegions, BarCodeHandle, 'auto', DecodedDataStrings)*/
  create_tuple_s(&TTemp[SP++],"auto");
  clear_obj(ho_SymbolRegions);
  destroy_tuple(hv_DecodedDataStrings);
  /***/T_find_bar_code(ho_Image, &ho_SymbolRegions, hv_BarCodeHandle, TTemp[SP-1], 
      &hv_DecodedDataStrings);
  destroy_tuple(TTemp[--SP]);

  /*get_bar_code_result (BarCodeHandle, 0, 'decoded_types', res)*/
  create_tuple_i(&TTemp[SP++],0);
  create_tuple_s(&TTemp[SP++],"decoded_types");
  destroy_tuple(hv_res);
  /***/T_get_bar_code_result(hv_BarCodeHandle, TTemp[SP-2], TTemp[SP-1], &hv_res);
  destroy_tuple(TTemp[--SP]);
  destroy_tuple(TTemp[--SP]);

  /*area_center (SymbolRegions, Area, Row, Column)*/
  destroy_tuple(hv_Area);
  destroy_tuple(hv_Row);
  destroy_tuple(hv_Column);
  /***/T_area_center(ho_SymbolRegions, &hv_Area, &hv_Row, &hv_Column);

  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_display (Image)*/
    /***/T_disp_obj(ho_Image, active_win);
    destroy_tuple(active_win);
  }
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_display (SymbolRegions)*/
    /***/T_disp_obj(ho_SymbolRegions, active_win);
    destroy_tuple(active_win);
  }
  if (hdev_window_stack_is_open())
  {
    Htuple active_win;
    create_tuple(&active_win,0);
    hdev_window_stack_get_active(&active_win);
    /*dev_disp_text (DecodedDataStrings, 'image', Row - 30, Column - 90, 'black', 'box_color', '#fce9d4cc')*/
    create_tuple_s(&TTemp[SP++],"image");
    create_tuple_i(&TTemp[SP++],30);
    T_tuple_sub(hv_Row,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_i(&TTemp[SP++],90);
    T_tuple_sub(hv_Column,TTemp[SP-1],&TTemp[SP]);
    destroy_tuple(TTemp[SP-1]);
    TTemp[SP-1]=TTemp[SP];
    create_tuple_s(&TTemp[SP++],"black");
    create_tuple_s(&TTemp[SP++],"box_color");
    create_tuple_s(&TTemp[SP++],"#fce9d4cc");
    /***/T_disp_text(active_win,hv_DecodedDataStrings, TTemp[SP-6], TTemp[SP-5], 
        TTemp[SP-4], TTemp[SP-3], TTemp[SP-2], TTemp[SP-1]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(TTemp[--SP]);
    destroy_tuple(active_win);
  }



  /****************************************************/
  /******************     End procedure   *************/
  /****************************************************/

  /* Clear temporary tuple stack */
  while (SP > 0)
    destroy_tuple(TTemp[--SP]);
  /* Clear temporary tuple vectors stack*/
  while (SPTV > 0)
    V_destroy_vector(TVTemp[--SPTV]);
  /* Clear local iconic variables */
  clear_obj(ho_Image);
  clear_obj(ho_SymbolRegions);

  /* Clear local control variables */
  destroy_tuple(hv_BarCodeHandle);
  destroy_tuple(hv_WindowHandle);
  destroy_tuple(hv_DecodedDataStrings);
  destroy_tuple(hv_res);
  destroy_tuple(hv_Area);
  destroy_tuple(hv_Row);
  destroy_tuple(hv_Column);

}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
/*
 * On OS X systems, we must have a CFRunLoop running on the main thread in
 * order for the HALCON graphics operators to work correctly, and run the
 * action function in a separate thread. A CFRunLoopTimer is used to make sure
 * the action function is not called before the CFRunLoop is running.
 * Note that starting with macOS 10.12, the run loop may be stopped when a
 * window is closed, so we need to put the call to CFRunLoopRun() into a loop
 * of its own.
 */
Htuple      gStartMutex = HTUPLE_INITIALIZER;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  T_unlock_mutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  /* Wait until the timer has fired to start processing. */
  T_lock_mutex(gStartMutex);
  T_unlock_mutex(gStartMutex);

  action();

  /* Tell the main thread to terminate itself. */
  T_lock_mutex(gStartMutex);
  gTerminate = TRUE;
  T_unlock_mutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  Htuple                AttribName, AttribValue;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  create_tuple_s(&AttribName,"type");
  create_tuple_s(&AttribValue,"sleep");
  T_create_mutex(AttribName,AttribValue,&gStartMutex);
  destroy_tuple(AttribValue);
  destroy_tuple(AttribName);
  T_lock_mutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    T_lock_mutex(gStartMutex);
    terminate = gTerminate;
    T_unlock_mutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  T_clear_mutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  /* Default settings used in HDevelop */
  int ret=0;
  Htuple Parameter, Value;

#if defined(_WIN32)
  set_system("use_window_thread", "true");
#elif defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
  XInitThreads();
#endif

  create_tuple(&Parameter,2);
  create_tuple(&Value,2);
  set_s(Parameter,"width",0);
  set_i(Value,512,0);
  set_s(Parameter,"height",1);
  set_i(Value,512,1);
  T_set_system(Parameter,Value);
  destroy_tuple(Value);
  destroy_tuple(Parameter);

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


