/***********************************************************
 * File generated by the HALCON-Compiler hcomp version 19.05
 * Usage: Interface to C++
 *
 * Software by: MVTec Software GmbH, www.mvtec.com
 ***********************************************************/


#ifndef HCPP_HHANDLE
#define HCPP_HHANDLE

namespace HalconCpp
{

// Represents a generic instance of a handle.
class LIntExport HHandle : public HHandleBase
{

public:

  // Create an uninitialized instance
  HHandle():HHandleBase() {}

  // Copy constructor
  HHandle(const HHandle& source) : HHandleBase(source) {}

  friend class HTupleElement;
  // Create HHandle from handle, taking ownership
  explicit HHandle(Hlong handle);

  bool operator==(const HHandle& obj) const
  {
    return HHandleBase::operator==(obj);
  }

  bool operator!=(const HHandle& obj) const
  {
    return HHandleBase::operator!=(obj);
  }

protected:

  // Internal Hphandle constructor
  HHandle(const Hphandle handle, bool copy): HHandleBase(handle,copy) {}

  // Verify matching semantic type ('handle')!
  virtual void AssertType(Hphandle handle) const;

public:

  // Deep copy of all data represented by this object instance
  HHandle Clone() const;




  /***************************************************************************
   * Operators                                                               *
   ***************************************************************************/

  // Clear the content of a handle. 
  void ClearHandle() const;

  // Deserialize a serialized item. 
  void DeserializeHandle(const HSerializedItem& SerializedItem);

  // Serialize the content of a handle. 
  HSerializedItem SerializeHandle() const;

  // Test if a tuple is serializable.
  Hlong TupleIsSerializable() const;

  // Check if a handle is valid. 
  HTuple TupleIsValidHandle() const;

  // Return the semantic type of a tuple.
  HString TupleSemType() const;

};

#if defined(HCPP_LEGACY_HANDLE_API)
  typedef HHandle HToolBase;
#endif

// forward declarations and types for internal array implementation

template<class T> class HSmartPtr;
template<class T> class HHandleBaseArrayRef;

typedef HHandleBaseArrayRef<HHandle> HHandleArrayRef;
typedef HSmartPtr< HHandleArrayRef > HHandleArrayPtr;


// Represents multiple tool instances
class LIntExport HHandleArray : public HHandleBaseArray
{

public:

  // Create empty array
  HHandleArray();

  // Create array from native array of tool instances
  HHandleArray(HHandle* classes, Hlong length);

  // Copy constructor
  HHandleArray(const HHandleArray &tool_array);

  // Destructor
  virtual ~HHandleArray();

  // Assignment operator
  HHandleArray &operator=(const HHandleArray &tool_array);

  // Clears array and all tool instances
  virtual void Clear();

  // Get array of native tool instances
  const HHandle* Tools() const;

  // Get number of tools
  virtual Hlong Length() const;

  // Create tool array from tuple of handles
  virtual void SetFromTuple(const HTuple& handles);

  // Get tuple of handles for tool array
  virtual HTuple ConvertToTuple() const;

protected:

// Smart pointer to internal data container
   HHandleArrayPtr *mArrayPtr;
};

}

#endif
